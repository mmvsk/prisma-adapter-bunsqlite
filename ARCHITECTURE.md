# Architecture & Implementation

This document provides detailed information about the design decisions, implementation details, and comparisons with official Prisma adapters.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Implementation Details](#implementation-details)
- [Comparison with Official Adapters](#comparison-with-official-adapters)
- [Design Decisions](#design-decisions)
- [Code Organization](#code-organization)
- [Testing Strategy](#testing-strategy)

## Overview

This adapter implements Prisma's `SqlDriverAdapter` interface for Bun's native `bun:sqlite` API. It provides a zero-dependency solution for using Prisma ORM with SQLite in Bun runtime environments.

### Goals

1. **Zero Dependencies**: Use only Bun's native APIs
2. **Full Compatibility**: Pass 100% of Prisma's driver adapter test suite
3. **Production Ready**: Handle all edge cases, errors, and type conversions
4. **Performance**: Leverage Bun's native performance characteristics
5. **Maintainability**: Follow official Prisma adapter patterns
6. **Full Migration Support**: Shadow database + programmatic migrations (v0.2.0+)
7. **Standalone Binaries**: Embed migrations for zero-dependency deployment (v0.2.0+)

## Architecture

### High-Level Structure

```
┌─────────────────────────────────────┐
│       Prisma Client                 │
│   (Generated by Prisma CLI)         │
└────────────┬────────────────────────┘
             │
             │ SqlDriverAdapter Interface
             │
┌────────────▼────────────────────────┐
│   PrismaBunSqlite (Factory)         │
│   - Creates adapter instance        │
│   - Configures SQLite PRAGMAs       │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSQLiteAdapter                  │
│   - Implements SqlDriverAdapter     │
│   - Manages transactions            │
│   - Executes scripts (migrations)   │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSQLiteQueryable (Base)         │
│   - queryRaw implementation         │
│   - executeRaw implementation       │
│   - Type conversion logic           │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSQLiteTransaction              │
│   - Transaction-specific methods    │
│   - commit() / rollback()           │
└─────────────────────────────────────┘
```

### Class Hierarchy

```typescript
BunSQLiteQueryable (base class)
├── BunSQLiteAdapter (main adapter)
└── BunSQLiteTransaction (transaction handler)

PrismaBunSqlite (factory)
```

## Implementation Details

### 1. Type System

The adapter uses Prisma's type system from `@prisma/driver-adapter-utils`:

```typescript
import {
  ColumnTypeEnum,
  type ArgType,
  type ColumnType,
  type SqlQuery,
  type SqlResultSet,
  // ... more types
} from "@prisma/driver-adapter-utils";
```

### 2. Column Type Detection

**Algorithm** (lines 347-385 in `src/bunsqlite-adapter.ts`):

1. **Extract table names** from SQL using regex:
   ```typescript
   const tablePattern = /(?:FROM|JOIN|INTO|UPDATE)\s+(?:`?\w+`?\.)?[`"']?(\w+)[`"']?/gi;
   ```
   - Matches: `FROM User`, `JOIN Post`, `INSERT INTO \`main\`.\`User\``
   - Handles: backticks, quotes, schema-qualified names

2. **Query PRAGMA** for each table:
   ```typescript
   const schema = this.db.prepare(`PRAGMA table_info("${tableName}")`).all();
   ```
   - Returns: `[{ name: "id", type: "INTEGER", ... }, ...]`

3. **Map declared types** using `mapDeclType()`:
   ```typescript
   "INTEGER" → ColumnTypeEnum.Int32
   "TEXT" → ColumnTypeEnum.Text
   "BLOB" → ColumnTypeEnum.Bytes
   // ... etc
   ```

4. **Infer missing types** from actual data:
   ```typescript
   typeof value === "bigint" → ColumnTypeEnum.Int64
   value instanceof ArrayBuffer → ColumnTypeEnum.Bytes
   // ... etc
   ```

**Why PRAGMA instead of `stmt.columns()`?**
- Gives schema-declared types, not inferred types
- Works with complex queries (JOINs, subqueries)
- More accurate for type coercion

### 3. Argument Mapping

The `mapArg()` function (lines 201-256) converts Prisma types to SQLite types:

```typescript
function mapArg(arg: unknown, argType: ArgType, options?: PrismaBunSqliteOptions)
```

**Key Conversions:**

| Input Type | ArgType | Output |
|------------|---------|--------|
| `boolean` | any | `1` or `0` |
| `"123"` | `int` | `123` (number) |
| `"3.14"` | `float` | `3.14` (number) |
| `"12345678901234"` | `bigint` | `12345678901234n` (BigInt) |
| `Date` | `datetime` | ISO8601 string or Unix timestamp |
| `"aGVsbG8="` | `bytes` | `Buffer` (from base64) |
| `[104,101,108,108,111]` | `bytes` | `Buffer` |

**DateTime Handling:**

```typescript
if (arg instanceof Date) {
  const format = options?.timestampFormat ?? "iso8601";
  switch (format) {
    case "unixepoch-ms":
      return arg.getTime();  // Unix timestamp in milliseconds
    case "iso8601":
      return arg.toISOString().replace("Z", "+00:00");  // ISO8601
  }
}
```

### 4. Row Mapping

The `mapRow()` function (lines 129-187) converts SQLite results to Prisma format:

**Key Transformations:**

```typescript
// BLOB → Array of numbers
if (value instanceof ArrayBuffer || value instanceof Buffer) {
  result[i] = Array.from(new Uint8Array(value));
}

// Float → Int (truncate)
if (typeof value === "number" &&
    (columnTypes[i] === ColumnTypeEnum.Int32 || columnTypes[i] === ColumnTypeEnum.Int64) &&
    !Number.isInteger(value)) {
  result[i] = Math.trunc(value);
}

// Unix timestamp → ISO8601
if ((typeof value === "number" || typeof value === "bigint") &&
    columnTypes[i] === ColumnTypeEnum.DateTime) {
  result[i] = new Date(Number(value)).toISOString();
}

// BigInt → String
if (typeof value === "bigint") {
  result[i] = value.toString();
}
```

### 5. Error Handling

The `convertDriverError()` function (lines 262-280) maps SQLite errors to Prisma error formats:

```typescript
switch (error.code) {
  case "SQLITE_BUSY":
    return { kind: "SocketTimeout", ... };

  case "SQLITE_CONSTRAINT_UNIQUE":
  case "SQLITE_CONSTRAINT_PRIMARYKEY":
    return { kind: "UniqueConstraintViolation", constraint: { fields }, ... };

  case "SQLITE_CONSTRAINT_NOTNULL":
    return { kind: "NullConstraintViolation", constraint: { fields }, ... };

  case "SQLITE_CONSTRAINT_FOREIGNKEY":
  case "SQLITE_CONSTRAINT_TRIGGER":
    return { kind: "ForeignKeyConstraintViolation", ... };

  default:
    // Message-based fallbacks for "no such table", "no such column", etc.
}
```

**Field Extraction:**

```typescript
// Extract field names from error message
// "UNIQUE constraint failed: User.email" → ["email"]
const fields = message
  .split("constraint failed: ")[1]
  ?.split(", ")
  .map((field) => field.split(".").pop()!);
```

### 6. Transaction Management

**Transaction Lifecycle & usePhantomQuery Coupling**

This adapter uses `usePhantomQuery: true`, which is **tightly coupled** with how we handle transaction lifecycle:

| Setting | COMMIT/ROLLBACK handled by | Phantom queries sent? |
|---------|---------------------------|----------------------|
| `usePhantomQuery: true` | **Adapter** (our code) | ✅ Yes (state verification) |
| `usePhantomQuery: false` | **Prisma Engine** | ❌ No |

**Our Implementation** (lines 444-482):

```typescript
async startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction> {
  // Acquire mutex to prevent concurrent transactions
  const releaseMutex = await this.transactionMutex.acquire();

  // SQLite only supports SERIALIZABLE
  if (isolationLevel && isolationLevel !== "SERIALIZABLE") {
    releaseMutex();
    throw new DriverAdapterError({ kind: "InvalidIsolationLevel", ... });
  }

  // Begin transaction explicitly
  this.db.run("BEGIN DEFERRED");
  this.transactionActive = true;

  return new BunSQLiteTransaction(this.db, options, this.adapterOptions, () => {
    this.transactionActive = false;
    releaseMutex();
  });
}
```

**Transaction Object:**

```typescript
class BunSQLiteTransaction extends BunSQLiteQueryable implements Transaction {
  async commit(): Promise<void> {
    // With usePhantomQuery: true, adapter MUST call COMMIT
    this.db.run("COMMIT");
    this.onComplete();  // Reset transactionActive flag + release mutex
  }

  async rollback(): Promise<void> {
    // With usePhantomQuery: true, adapter MUST call ROLLBACK
    this.db.run("ROLLBACK");
    this.onComplete();
  }
}
```

**Why Manual BEGIN/COMMIT/ROLLBACK?**

1. **usePhantomQuery: true requires it**: When this flag is enabled, Prisma expects the adapter to manage the full transaction lifecycle
2. **Matches @prisma/adapter-libsql**: The official libsql adapter uses the same pattern
3. **Different from better-sqlite3**: That adapter uses `usePhantomQuery: false` and lets Prisma handle COMMIT/ROLLBACK

**IMPORTANT**: These two settings MUST be changed together:
- If we switch to `usePhantomQuery: false`, we must remove COMMIT/ROLLBACK from transaction methods
- If we keep `usePhantomQuery: true`, we must keep explicit COMMIT/ROLLBACK
- Mixing them causes "Transaction already closed" or uncommitted writes

**AsyncMutex for Transaction Serialization**

SQLite only allows one write transaction at a time. We use a custom AsyncMutex (34 lines, zero dependencies) to serialize transactions:

```typescript
class AsyncMutex {
  private locked = false;
  private queue: Array<() => void> = [];

  async acquire(): Promise<() => void> {
    if (!this.locked) {
      this.locked = true;
      return () => this.release();
    }
    // Queue if already locked
    return new Promise<() => void>((resolve) => {
      this.queue.push(() => {
        this.locked = true;
        resolve(() => this.release());
      });
    });
  }

  private release(): void {
    const next = this.queue.shift();
    if (next) next();
    else this.locked = false;
  }
}
```

**Why custom AsyncMutex instead of a library?**
- Zero dependencies goal
- Simple implementation (34 lines)
- Sufficient for SQLite's single-writer model

### 7. Script Execution

Uses native `db.exec()` for migrations (lines 515-522):

```typescript
async executeScript(script: string): Promise<void> {
  try {
    // Use native exec() which properly handles multiple statements
    this.db.exec(script);
  } catch (error: any) {
    throw new DriverAdapterError(convertDriverError(error));
  }
}
```

**Why `db.exec()` instead of splitting by semicolons?**
- Handles semicolons inside strings correctly
- Handles multi-line statements
- Native SQLite parsing
- Matches official adapter behavior

### 8. Factory Pattern

The `PrismaBunSqlite` factory (lines 588-611):

```typescript
export class PrismaBunSqlite {
  readonly provider = "sqlite" as const;
  readonly adapterName = "@prisma/adapter-bunsqlite";

  async connect(): Promise<SqlDriverAdapter> {
    const db = new Database(this.dbPath);

    // Configure SQLite for optimal Prisma usage
    db.run("PRAGMA foreign_keys = ON");      // Required for cascades
    db.run("PRAGMA busy_timeout = 5000");    // Handle locks
    db.run("PRAGMA journal_mode = WAL");     // Performance

    return new BunSQLiteAdapter(db, this.options);
  }
}
```

## Critical Fixes in v0.1.1

This section documents critical bugs discovered and fixed after the initial v0.1.0 release.

### 1. Data Corruption with Duplicate Column Names (CRITICAL)

**The Bug:**

When queries returned duplicate column names (common in JOINs), using `stmt.all()` caused data corruption:

```typescript
// Query: SELECT User.id, Profile.id, User.name, Profile.bio FROM User JOIN Profile ...
// BEFORE (BUGGY):
const rows = stmt.all(...args);
// Returns: [{ id: 10, name: "Alice", bio: "..." }]
// ❌ Lost User.id! Only kept Profile.id

const rowArrays = rows.map(row => columnNames.map(col => row[col]));
// Returns: [[10, 10, "Alice", "..."]]  // Wrong! Both IDs are the same
```

**The Fix:**

Changed to `stmt.values()` which returns arrays instead of objects:

```typescript
// AFTER (FIXED):
const rowArrays = stmt.values(...args);
// Returns: [[5, 10, "Alice", "..."]]  // Correct! User.id=5, Profile.id=10
```

**Impact:** Without this fix, any query with duplicate column names would silently return wrong data.

**Test Added:** `$queryRaw - preserves all columns in joins (duplicate names)` (line 753 in test-suite.ts)

### 2. Error Mapping Broken (CRITICAL)

**The Bug:**

Bun SQLite errors sometimes only have `.errno` (number) without `.code` (string):

```typescript
// Bun returns: { errno: 1, code: undefined, message: "..." }
// BEFORE (BUGGY):
if (!error?.code) throw error;  // ❌ Unhandled error!
```

**The Fix:**

Added full errno-to-code mapping:

```typescript
const SQLITE_ERROR_MAP: Record<number, string> = {
  1: "SQLITE_ERROR",
  5: "SQLITE_BUSY",
  2067: "SQLITE_CONSTRAINT_UNIQUE",
  // ... all 25+ SQLite error codes
};

function convertDriverError(error: any): any {
  // Accept both .code and .errno
  const code = error.code || SQLITE_ERROR_MAP[error.errno] || "SQLITE_UNKNOWN";
  // ... rest of error mapping
}
```

**Impact:** Without this fix, many errors (missing table, syntax errors) were not properly wrapped as Prisma errors.

**Tests Added:**
- `Missing table error is properly wrapped (errno-only error)` (line 993)
- `Syntax error is properly wrapped (errno-only error)` (line 1003)

### 3. BigInt Precision Loss Prevention

**The Issue:**

JavaScript numbers can't safely represent integers beyond `Number.MAX_SAFE_INTEGER` (2^53-1), but SQLite supports 64-bit integers (2^63-1).

**The Solution:**

Enable `safeIntegers: true` by default:

```typescript
export type PrismaBunSqliteOptions = {
  /**
   * Enable safe 64-bit integer handling.
   * When true, BIGINT columns return as BigInt instead of number,
   * preventing precision loss for values > Number.MAX_SAFE_INTEGER.
   * @default true
   */
  safeIntegers?: boolean;
};

// In factory:
const safeIntegers = this.config.safeIntegers !== false;  // Default: true
const db = new Database(dbPath, { safeIntegers });
```

**Impact:** Prevents silent data corruption when working with large integers (timestamps, IDs, etc).

**Test Added:** `BigInt handling - maximum 64-bit values (2^63-1)` (adapter-specific)

### 4. Statement Metadata Access (ACCEPTABLE RISK)

**The Issue:**

We access undocumented Bun APIs to get query metadata:

```typescript
const columnNames = (stmt as any).columnNames || [];
const declaredTypes = (stmt as any).declaredTypes || [];
```

**Why Needed:**

- Essential for preserving column order in results
- Required for proper type coercion
- No official Bun API exists (as of Bun v1.1.x)

**Safeguards:**

1. Fallback to empty arrays if properties don't exist
2. Detect column count mismatches and generate placeholder names:
   ```typescript
   if (firstRow && firstRow.length > columnNames.length) {
     const missingCount = actualColumnCount - columnNames.length;
     for (let i = 0; i < missingCount; i++) {
       columnNames.push(`column_${columnNames.length}`);
     }
   }
   ```

**Status:** Acceptable risk. Works reliably in practice. Future improvements:
- File Bun issue to make these official APIs
- Add runtime checks for property existence
- Document in code comments

**Documented:** Added explanatory comments in v0.1.1 (see lines 382-387 in src/bunsqlite-adapter.ts)

## New Features in v0.2.0

### 1. Shadow Database Support

**What it enables:**
- Full `prisma migrate dev` compatibility
- Migration testing and diffing
- Works with `prisma.config.ts` and JS engine

**Implementation:**

The factory class now implements `SqlMigrationAwareDriverAdapterFactory`:

```typescript
export class PrismaBunSqlite implements SqlMigrationAwareDriverAdapterFactory {
  async connectToShadowDb(): Promise<SqlDriverAdapter> {
    // Defaults to :memory: for speed
    const shadowUrl = this.config.shadowDatabaseUrl ?? ":memory:";
    const db = this.createConnection(shadowUrl);
    return new BunSQLiteAdapter(db, this.config);
  }
}
```

**Key features:**
- Shadow DB defaults to `:memory:` for maximum speed
- Inherits all config options (safeIntegers, timestampFormat)
- Completely isolated from main database
- WAL mode automatically disabled for :memory: databases

**Test coverage:** 9 comprehensive tests ensuring shadow DB works correctly

---

### 2. Programmatic Migration Utilities

**New module:** `src/migrations.ts` (372 lines)

**What it enables:**
- Run migrations from TypeScript code
- Create :memory: databases with migrations (lightning fast tests!)
- Embed migrations in standalone Bun binaries
- Custom migration workflows

**API Overview:**

```typescript
// Create test database with migrations
const adapter = await createTestDatabase([
  { name: "001_init", sql: "CREATE TABLE users (...);" }
]);

// Run migrations manually
await runMigrations(adapter, migrations, {
  logger: console.log,
  skipApplied: true  // Default
});

// Load migrations from filesystem
const migrations = await loadMigrationsFromDir("./prisma/migrations");

// Query migration status
const applied = await getAppliedMigrations(adapter);
const pending = await getPendingMigrations(adapter, allMigrations);
```

**Migration Tracking:**

Uses Prisma-compatible `_prisma_migrations` table:

```sql
CREATE TABLE _prisma_migrations (
  id TEXT PRIMARY KEY,
  checksum TEXT NOT NULL,
  migration_name TEXT NOT NULL,
  finished_at DATETIME,
  started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  applied_steps_count INTEGER DEFAULT 0
);
```

**Test coverage:** 11 comprehensive tests covering all migration utilities

---

### 3. Type System Improvements

**Before (v0.1.x):**
```typescript
export type PrismaBunSqlite3Options = { ... }  // Inconsistent naming
export type PrismaBunSqliteConfig = { ... }
```

**After (v0.2.0):**
```typescript
export type PrismaBunSqliteOptions = { ... }   // Consistent naming
export type PrismaBunSqliteConfig = {
  url: string;
  shadowDatabaseUrl?: string;  // New!
} & PrismaBunSqliteOptions;
```

**Changes:**
- Renamed `PrismaBunSqlite3Options` → `PrismaBunSqliteOptions` (consistent with class name)
- Added `shadowDatabaseUrl` to config
- Better JSDoc comments throughout
- All TypeScript strict mode errors fixed

---

### 4. Test Structure Simplification

**Before (v0.1.x):**
- `tests/common/test-suite.ts` - Shared test suite
- `tests/bunsqlite-adapter.test.ts` - Wrapper for bunsqlite
- `tests/libsql-adapter.test.ts` - Wrapper for libsql (baseline)
- Dependency on `@prisma/adapter-libsql`

**After (v0.2.0):**
- `tests/general.test.ts` - All core adapter tests (57 tests)
- `tests/migrations.test.ts` - Migration utility tests (11 tests)
- `tests/shadow-database.test.ts` - Shadow DB tests (9 tests)
- **Zero external adapter dependencies**

**Benefits:**
- Simpler test structure
- Faster CI (no libsql baseline needed)
- Easier to maintain
- Cleaner codebase

---

### 5. Examples and Documentation

**New Examples:**
- `examples/standalone-binary.ts` - Embedded migrations in Bun binary
- `examples/bundle-with-migration-files.ts` - Bundle Prisma migrations at build time
- `examples/test-with-memory-db-example.ts` - :memory: testing patterns
- `examples/README.md` - Complete guide with deployment strategies

**Updated Documentation:**
- README.md - Added migration utilities section
- CHANGELOG.md - Comprehensive v0.2.0 entry
- BACKLOG.md - Marked shadow DB as completed
- prisma.config.ts - Now uses JS engine with adapter

---

## Comparison with Official Adapters

### vs `@prisma/adapter-better-sqlite3`

| Feature | better-sqlite3 | bun:sqlite (ours) |
|---------|----------------|-------------------|
| **Runtime** | Node.js | Bun |
| **API Type** | Synchronous | Synchronous |
| **Dependencies** | `better-sqlite3` (native) | Zero (Bun built-in) |
| **executeScript** | `db.exec()` | `db.exec()` ✅ |
| **Error Codes** | String codes + errno map | String codes + errno map ✅ |
| **Argument Mapping** | `mapArg()` | `mapArg()` ✅ |
| **Boolean Conversion** | `1/0` | `1/0` ✅ |
| **usePhantomQuery** | `false` (Prisma handles tx) | `true` (adapter handles tx) |
| **Transaction Method** | No explicit COMMIT/ROLLBACK | Manual BEGIN/COMMIT/ROLLBACK |
| **Transaction Safety** | `async-mutex` library | Custom AsyncMutex (34 lines) |
| **Column Detection** | `stmt.columns()` API | `stmt.values()` + metadata |
| **DateTime Format** | Options support | Options support ✅ |
| **Safe Integers** | Optional | Default enabled ✅ |

**Key Differences:**

1. **Transaction Lifecycle** (IMPORTANT):
   - **better-sqlite3**: Uses `usePhantomQuery: false`, so Prisma Engine sends COMMIT/ROLLBACK queries. The adapter's `commit()` method just releases a mutex.
   - **Ours**: Uses `usePhantomQuery: true`, so the adapter MUST call `db.run("COMMIT")` and `db.run("ROLLBACK")` explicitly.
   - **Both are correct**: These are two valid design patterns. Matches `@prisma/adapter-libsql` which also uses `usePhantomQuery: true`.
   - **Rationale**: The two approaches are tightly coupled - changing one requires changing the other.

2. **Transaction Locking**:
   - **better-sqlite3**: Uses `async-mutex` npm package (dependency)
   - **Ours**: Custom AsyncMutex implementation (34 lines, zero dependencies)
   - **Rationale**: SQLite is single-threaded; simple queue-based mutex sufficient

3. **Column Data Retrieval**:
   - **better-sqlite3**: Uses `stmt.all()` to get objects, then `stmt.columns()` for metadata
   - **Ours**: Uses `stmt.values()` to get arrays (preserves duplicate columns)
   - **Rationale**: Arrays prevent data corruption when column names duplicate (JOINs)

4. **Safe Integers**:
   - **better-sqlite3**: Opt-in (`safeIntegers: false` by default)
   - **Ours**: Opt-out (`safeIntegers: true` by default)
   - **Rationale**: Prevent silent data corruption by default

### vs `@prisma/adapter-libsql`

| Feature | libsql | bun:sqlite (ours) |
|---------|--------|-------------------|
| **Runtime** | Node.js or Bun | Bun only |
| **API Type** | Async (can be networked) | Sync (local only) |
| **Network Support** | ✅ (Turso, remote) | ❌ (local file only) |
| **Dependencies** | `@libsql/client` | Zero |
| **Connection** | URL-based | File path |
| **Transaction** | Automatic via libsql | Manual BEGIN/COMMIT |

**When to use which:**

- **Use libsql** if you need networked SQLite (Turso), edge deployment
- **Use bun:sqlite** for local-only apps, maximum performance, zero deps

## Design Decisions

### 1. Why Manual Transaction Management?

**Decision**: Use manual `BEGIN`/`COMMIT`/`ROLLBACK` instead of `db.transaction()`

**Reasoning**:
- Matches official better-sqlite3 adapter pattern
- Prisma expects to control transaction lifecycle
- `db.transaction()` returns a function, incompatible with Prisma's API
- All tests pass with manual approach

**Code**:
```typescript
// ❌ Can't use this - returns a function
const txFunc = db.transaction(() => {
  db.run("INSERT ...");
  db.run("UPDATE ...");
});
txFunc(); // Executes

// ✅ Instead use this - Prisma-compatible
db.run("BEGIN");
db.run("INSERT ...");
db.run("UPDATE ...");
db.run("COMMIT");
```

### 2. Why `usePhantomQuery: true`?

**Decision**: Set `usePhantomQuery: true` in transaction options

**What it means**:
- When `true`: Prisma sends "phantom queries" to verify transaction state, and expects the adapter to call BEGIN/COMMIT/ROLLBACK
- When `false`: Prisma Engine sends explicit COMMIT/ROLLBACK queries, and the adapter just manages connection state

**Reasoning**:
- Matches `@prisma/adapter-libsql` pattern (official adapter)
- Simpler implementation with manual transaction lifecycle
- **CRITICAL**: This setting is tightly coupled with transaction methods - both must be changed together
- Changing to `false` would require complete rewrite of transaction lifecycle

**Trade-offs**:
- ✅ Adapter has full control over transaction lifecycle
- ✅ Simple BEGIN/COMMIT/ROLLBACK implementation
- ⚠️ Slightly more query overhead (phantom queries for state verification)
- ⚠️ Different pattern than better-sqlite3 (which uses `false`)

**Note**: Both `true` and `false` are valid designs used by official adapters

### 3. Why PRAGMA for Column Types?

**Decision**: Use `PRAGMA table_info()` instead of `stmt.columns()`

**Reasoning**:
- bun:sqlite doesn't expose `stmt.columns()` API
- PRAGMA gives schema-declared types, not runtime-inferred
- More accurate for type coercion (e.g., BLOB columns)
- Works with all query types (SELECT, INSERT, etc.)

### 4. Why String Error Codes?

**Decision**: Use string codes (`"SQLITE_CONSTRAINT_UNIQUE"`) not numeric

**Reasoning**:
- bun:sqlite provides string codes natively
- More readable and maintainable
- Matches better-sqlite3 adapter exactly
- No need for numeric code mappings

### 5. Why Options Support?

**Decision**: Add `PrismaBunSqliteOptions` with `timestampFormat`

**Reasoning**:
- Matches official adapter API
- Some users prefer Unix timestamps over ISO8601
- Allows future extensibility
- Zero overhead if not used

## Code Organization

### File Structure

```
src/
├── bunsqlite-adapter.ts    # Main adapter implementation
│   ├── Types & Interfaces
│   ├── Type Mapping
│   ├── Row Conversion
│   ├── Argument Mapping
│   ├── Error Conversion
│   ├── BunSQLiteQueryable (Base)
│   ├── BunSQLiteTransaction
│   ├── BunSQLiteAdapter
│   └── PrismaBunSqlite Factory
├── migrations.ts           # Migration utilities (v0.2.0+)
│   ├── runMigrations()
│   ├── createTestDatabase()
│   ├── loadMigrationsFromDir()
│   ├── getAppliedMigrations()
│   └── getPendingMigrations()
└── index.ts                # Public exports

tests/
├── general.test.ts         # Core adapter tests (57 tests)
├── migrations.test.ts      # Migration utilities tests (11 tests)
└── shadow-database.test.ts # Shadow DB tests (9 tests)

prisma/
├── schema.prisma           # Test schema
└── generated/              # Generated Prisma Client

examples/                   # v0.2.0+ examples
├── standalone-binary.ts
├── bundle-with-migration-files.ts
├── test-with-memory-db-example.ts
└── README.md
```

### Key Functions

| Function | Lines | Purpose |
|----------|-------|---------|
| `mapDeclType()` | 27-69 | Maps SQLite type names to Prisma ColumnType |
| `inferColumnType()` | 74-92 | Infers column type from runtime value |
| `getColumnTypes()` | 97-124 | Combines declared + inferred types |
| `mapRow()` | 129-187 | Converts SQLite row to Prisma format |
| `mapArg()` | 201-256 | Converts Prisma arg to SQLite format |
| `convertDriverError()` | 262-349 | Maps SQLite errors to Prisma errors |
| `getColumnTypesForQuery()` | 430-467 | Detects column types via PRAGMA |

## Testing Strategy

### Test Structure (v0.2.0+)

**Test Suites:**

1. **`tests/general.test.ts`** - Core adapter functionality (57 tests)
   - CRUD operations (12 tests)
   - Relations (6 tests)
   - Filtering & querying (9 tests)
   - Aggregations (3 tests)
   - Transactions (3 tests)
   - Raw queries (4 tests)
   - Type coercion (7 tests)
   - Error handling (4 tests)
   - Edge cases (6 tests)
   - Includes regression tests for v0.1.1 critical fixes

2. **`tests/migrations.test.ts`** - Migration utilities (11 tests)
   - runMigrations applies migrations
   - runMigrations skips already applied
   - runMigrations tracks in _prisma_migrations
   - getAppliedMigrations returns list
   - getPendingMigrations returns unapplied
   - createTestDatabase creates :memory: with migrations
   - Complex SQL with comments
   - Idempotent migrations
   - Foreign key preservation

3. **`tests/shadow-database.test.ts`** - Shadow DB (9 tests)
   - Creates separate adapter instances
   - Defaults to :memory:
   - Supports custom URL
   - Isolated from main database
   - executeScript support
   - Multiple usage
   - Config inheritance (safeIntegers, timestampFormat)

**Test Categories:**

1. **CRUD Operations** (12 tests)
   - create, findUnique, findMany, findFirst
   - update, updateMany, delete, deleteMany
   - upsert, count

2. **Relations** (6 tests)
   - Nested creates
   - Include queries
   - Cascade deletes

3. **Filtering & Querying** (9 tests)
   - Where clauses
   - OrderBy, pagination
   - Distinct

4. **Aggregations** (3 tests)
   - count(), aggregate(), groupBy()

5. **Transactions** (3 tests)
   - Interactive commit
   - Interactive rollback
   - Sequential

6. **Raw Queries** (4 tests)
   - $queryRaw SELECT
   - $executeRaw INSERT/UPDATE/DELETE

7. **Type Coercion** (7 tests)
   - DateTime, BigInt, Boolean
   - Decimal, JSON, Bytes
   - Null handling

8. **Error Handling** (4 tests)
   - P2002 (unique constraint)
   - P2003 (foreign key)
   - P2025 (record not found)
   - P2011 (null constraint)

9. **Edge Cases** (6 tests)
   - Empty strings
   - Large numbers
   - Special characters
   - Concurrent operations

### Running Tests

```bash
# All tests (77 tests total)
bun test

# Core adapter only
bun test tests/general.test.ts

# Migration utilities only
bun test tests/migrations.test.ts

# Shadow database only
bun test tests/shadow-database.test.ts

# Verbose output
bun test --verbose
```

### Test Results

```
✅ General Tests:         57/57 tests passing (v0.2.0)
✅ Migration Tests:       11/11 tests passing (v0.2.0)
✅ Shadow Database Tests:  9/9 tests passing (v0.2.0)
──────────────────────────────────────────────────────
✅ Total:                 77/77 tests passing
```

**Test Evolution:**
- v0.1.0: 110 tests
- v0.1.1: 113 tests (added regression tests)
- v0.2.0: 77 tests (consolidated + new features, removed baseline duplication)

## Performance Considerations

### Optimizations

1. **Prepared Statements**: All queries use `db.prepare()`
2. **WAL Mode**: Enabled by default for better concurrency
3. **Type Caching**: Column types cached per query
4. **Direct API**: No middleware, direct `bun:sqlite` calls

### Benchmarks

(TODO: Add benchmarks comparing with better-sqlite3 and libsql)

## Future Improvements

### Planned Enhancements (See `BACKLOG.md`)

**High Priority (Next Release):**
1. **Debug Logging**: Add `Debug` from `@prisma/driver-adapter-utils` for troubleshooting
2. **Dead Code Removal**: Remove unused `getColumnTypesForQuery()` method
3. **Base64 BLOB Investigation**: Document or remove base64 BLOB handling code
4. **Statement Metadata Safety**: File Bun issue to make `columnNames`/`declaredTypes` official API

**Medium Priority:**
1. **Modular Structure**: Refactor into separate files (adapter.ts, transaction.ts, conversion.ts, errors.ts)
2. **Comprehensive JSDoc**: Add JSDoc comments to all public APIs

**v0.3.0 - Performance & Optimization:**
1. **Performance Benchmarks**: Add comprehensive benchmarks vs libsql and better-sqlite3
2. **usePhantomQuery: false**: Consider switching for fewer queries (requires transaction rewrite)
3. **Schema Caching**: Cache PRAGMA results to reduce repeated schema queries

**v1.0.0 - Production Hardening:**
1. **Extensive Production Testing**: Used in 3+ projects for 3+ months
2. **API Stability**: Lock API for semantic versioning
3. **Comprehensive Documentation**: Migration guides, troubleshooting, performance tuning

### Known Limitations

1. **SQLite Constraints**: Inherits all SQLite limitations (single writer, no network, etc.)
2. **Decimal Precision**: Limited by SQLite's lack of native decimal type
3. **Transaction Isolation**: Only SERIALIZABLE (SQLite limitation)
4. **Undocumented Bun APIs**: Relies on `columnNames`/`declaredTypes` properties (not officially documented)

## Contributing

When contributing, please:

1. **Read this document** to understand design decisions
2. **Run all tests** before submitting PR
3. **Add tests** for new features
4. **Follow existing patterns** (match official adapter style)
5. **Update documentation** if changing behavior

## References

- [Prisma Driver Adapters Docs](https://www.prisma.io/docs/orm/overview/databases/database-drivers)
- [Bun SQLite API](https://bun.sh/docs/api/sqlite)
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [Official better-sqlite3 Adapter](https://github.com/prisma/prisma/tree/main/packages/adapter-better-sqlite3)
- [Official libsql Adapter](https://github.com/prisma/prisma/tree/main/packages/adapter-libsql)
