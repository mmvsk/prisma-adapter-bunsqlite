# Architecture & Implementation

This document provides detailed information about the design decisions, implementation details, and comparisons with official Prisma adapters.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Implementation Details](#implementation-details)
- [Comparison with Official Adapters](#comparison-with-official-adapters)
- [Design Decisions](#design-decisions)
- [Code Organization](#code-organization)
- [Testing Strategy](#testing-strategy)

## Overview

This adapter implements Prisma's `SqlDriverAdapter` interface for Bun's native `bun:sqlite` API. It provides a zero-dependency solution for using Prisma ORM with SQLite in Bun runtime environments.

### Goals

1. **Zero Dependencies**: Use only Bun's native APIs
2. **Full Compatibility**: Pass 100% of Prisma's driver adapter test suite
3. **Production Ready**: Handle all edge cases, errors, and type conversions
4. **Performance**: Leverage Bun's native performance characteristics
5. **Maintainability**: Follow official Prisma adapter patterns
6. **Full Migration Support**: Shadow database + programmatic migrations (v0.2.0+)
7. **Standalone Binaries**: Embed migrations for zero-dependency deployment (v0.2.0+)

## Architecture

### High-Level Structure

```
┌─────────────────────────────────────┐
│       Prisma Client                 │
│   (Generated by Prisma CLI)         │
└────────────┬────────────────────────┘
             │
             │ SqlDriverAdapter Interface
             │
┌────────────▼────────────────────────┐
│   PrismaBunSqlite (Factory)         │
│   - Creates adapter instance        │
│   - Configures SQLite PRAGMAs       │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSqliteAdapter                  │
│   - Implements SqlDriverAdapter     │
│   - Manages transactions            │
│   - Executes scripts (migrations)   │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSqliteQueryable (Base)         │
│   - queryRaw implementation         │
│   - executeRaw implementation       │
│   - Type conversion logic           │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSqliteTransaction              │
│   - Transaction-specific methods    │
│   - commit() / rollback()           │
└─────────────────────────────────────┘
```

### Class Hierarchy

```typescript
BunSqliteQueryable (base class)
├── BunSqliteAdapter (main adapter)
└── BunSqliteTransaction (transaction handler)

PrismaBunSqlite (factory)
```

## Implementation Details

### 1. Type System

The adapter uses Prisma's type system from `@prisma/driver-adapter-utils`:

```typescript
import {
  ColumnTypeEnum,
  type ArgType,
  type ColumnType,
  type SqlQuery,
  type SqlResultSet,
  // ... more types
} from "@prisma/driver-adapter-utils";
```

### 2. Column Type Detection

**Algorithm** (lines 347-385 in `src/adapter.ts`):

1. **Extract table names** from SQL using regex:
   ```typescript
   const tablePattern = /(?:FROM|JOIN|INTO|UPDATE)\s+(?:`?\w+`?\.)?[`"']?(\w+)[`"']?/gi;
   ```
   - Matches: `FROM User`, `JOIN Post`, `INSERT INTO \`main\`.\`User\``
   - Handles: backticks, quotes, schema-qualified names

2. **Query PRAGMA** for each table:
   ```typescript
   const schema = this.db.prepare(`PRAGMA table_info("${tableName}")`).all();
   ```
   - Returns: `[{ name: "id", type: "INTEGER", ... }, ...]`

3. **Map declared types** using `mapDeclType()`:
   ```typescript
   "INTEGER" → ColumnTypeEnum.Int32
   "TEXT" → ColumnTypeEnum.Text
   "BLOB" → ColumnTypeEnum.Bytes
   // ... etc
   ```

4. **Infer missing types** from actual data:
   ```typescript
   typeof value === "bigint" → ColumnTypeEnum.Int64
   value instanceof ArrayBuffer → ColumnTypeEnum.Bytes
   // ... etc
   ```

**Why PRAGMA instead of `stmt.columns()`?**
- Gives schema-declared types, not inferred types
- Works with complex queries (JOINs, subqueries)
- More accurate for type coercion

### 3. Argument Mapping

The `mapArg()` function (lines 201-256) converts Prisma types to SQLite types:

```typescript
function mapArg(arg: unknown, argType: ArgType, options?: PrismaBunSqliteOptions)
```

**Key Conversions:**

| Input Type | ArgType | Output |
|------------|---------|--------|
| `boolean` | any | `1` or `0` |
| `"123"` | `int` | `123` (number) |
| `"3.14"` | `float` | `3.14` (number) |
| `"12345678901234"` | `bigint` | `12345678901234n` (BigInt) |
| `Date` | `datetime` | ISO8601 string or Unix timestamp |
| `"aGVsbG8="` | `bytes` | `Buffer` (from base64) |
| `[104,101,108,108,111]` | `bytes` | `Buffer` |

**DateTime Handling:**

```typescript
if (arg instanceof Date) {
  const format = options?.timestampFormat ?? "iso8601";
  switch (format) {
    case "unixepoch-ms":
      return arg.getTime();  // Unix timestamp in milliseconds
    case "iso8601":
      return arg.toISOString().replace("Z", "+00:00");  // ISO8601
  }
}
```

### 4. Row Mapping

The `mapRow()` function (lines 129-187) converts SQLite results to Prisma format:

**Key Transformations:**

```typescript
// BLOB → Array of numbers
if (value instanceof ArrayBuffer || value instanceof Buffer) {
  result[i] = Array.from(new Uint8Array(value));
}

// Float → Int (truncate)
if (typeof value === "number" &&
    (columnTypes[i] === ColumnTypeEnum.Int32 || columnTypes[i] === ColumnTypeEnum.Int64) &&
    !Number.isInteger(value)) {
  result[i] = Math.trunc(value);
}

// Unix timestamp → ISO8601
if ((typeof value === "number" || typeof value === "bigint") &&
    columnTypes[i] === ColumnTypeEnum.DateTime) {
  result[i] = new Date(Number(value)).toISOString();
}

// BigInt → String
if (typeof value === "bigint") {
  result[i] = value.toString();
}
```

### 5. Error Handling

The `convertDriverError()` function (lines 262-280) maps SQLite errors to Prisma error formats:

```typescript
switch (error.code) {
  case "SQLITE_BUSY":
    return { kind: "SocketTimeout", ... };

  case "SQLITE_CONSTRAINT_UNIQUE":
  case "SQLITE_CONSTRAINT_PRIMARYKEY":
    return { kind: "UniqueConstraintViolation", constraint: { fields }, ... };

  case "SQLITE_CONSTRAINT_NOTNULL":
    return { kind: "NullConstraintViolation", constraint: { fields }, ... };

  case "SQLITE_CONSTRAINT_FOREIGNKEY":
  case "SQLITE_CONSTRAINT_TRIGGER":
    return { kind: "ForeignKeyConstraintViolation", ... };

  default:
    // Message-based fallbacks for "no such table", "no such column", etc.
}
```

**Field Extraction:**

```typescript
// Extract field names from error message
// "UNIQUE constraint failed: User.email" → ["email"]
const fields = message
  .split("constraint failed: ")[1]
  ?.split(", ")
  .map((field) => field.split(".").pop()!);
```

### 6. Transaction Management

**Transaction Lifecycle & usePhantomQuery: false**

This adapter uses `usePhantomQuery: false`, matching the **official @prisma/adapter-better-sqlite3** implementation:

| Setting | COMMIT/ROLLBACK handled by | How it works |
|---------|---------------------------|--------------|
| `usePhantomQuery: false` | **Prisma Engine** | Engine sends COMMIT/ROLLBACK SQL via executeRaw() |
| `usePhantomQuery: true` | **Adapter** (our code) | Adapter executes COMMIT/ROLLBACK in commit()/rollback() methods |

**Our Implementation**:

```typescript
async startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction> {
  // Acquire mutex to prevent concurrent transactions (SQLite single-writer)
  const releaseLock = await this.transactionMutex.acquire();

  // SQLite only supports SERIALIZABLE
  if (isolationLevel && isolationLevel !== "SERIALIZABLE") {
    releaseLock();
    throw new DriverAdapterError({ kind: "InvalidIsolationLevel", ... });
  }

  // Begin transaction explicitly
  this.db.run("BEGIN");

  const options: TransactionOptions = {
    usePhantomQuery: false  // Match official better-sqlite3 adapter
  };

  return new BunSqliteTransaction(this.db, options, this.adapterOptions, releaseLock);
}
```

**Transaction Object:**

```typescript
class BunSqliteTransaction extends BunSqliteQueryable implements Transaction {
  async commit(): Promise<void> {
    // With usePhantomQuery: false, Prisma engine sends COMMIT via executeRaw
    // This method just releases the transaction lock
    this.releaseLock();
  }

  async rollback(): Promise<void> {
    // With usePhantomQuery: false, Prisma engine sends ROLLBACK via executeRaw
    // This method just releases the transaction lock
    this.releaseLock();
  }
}
```

**How Transaction Lifecycle Works:**

1. **App calls** `prisma.$transaction()`
2. **Adapter's startTransaction()** acquires mutex lock and executes `BEGIN`
3. **App performs queries** → all go through adapter's queryRaw/executeRaw
4. **Prisma engine sends** `COMMIT` or `ROLLBACK` SQL → adapter executes via executeRaw()
5. **Transaction methods called** → adapter's commit()/rollback() releases mutex lock

**Why usePhantomQuery: false?**

1. **Matches official pattern**: `@prisma/adapter-better-sqlite3` uses this approach
2. **Cleaner separation**: Engine controls transaction SQL, adapter controls locking
3. **Simpler implementation**: commit()/rollback() are just mutex unlocks
4. **No edge cases**: No need to intercept or special-case COMMIT/ROLLBACK SQL

**AsyncMutex for Transaction Serialization**

SQLite only allows one write transaction at a time. We use a custom AsyncMutex (34 lines, zero dependencies) to serialize transactions:

```typescript
class AsyncMutex {
  private locked = false;
  private queue: Array<() => void> = [];

  async acquire(): Promise<() => void> {
    if (!this.locked) {
      this.locked = true;
      return () => this.release();
    }
    // Queue if already locked
    return new Promise<() => void>((resolve) => {
      this.queue.push(() => {
        this.locked = true;
        resolve(() => this.release());
      });
    });
  }

  private release(): void {
    const next = this.queue.shift();
    if (next) next();
    else this.locked = false;
  }
}
```

**Why custom AsyncMutex instead of a library?**
- Zero dependencies goal
- Simple implementation (34 lines)
- Sufficient for SQLite's single-writer model

### 7. Script Execution

Uses native `db.exec()` for migrations (lines 515-522):

```typescript
async executeScript(script: string): Promise<void> {
  try {
    // Use native exec() which properly handles multiple statements
    this.db.exec(script);
  } catch (error: any) {
    throw new DriverAdapterError(convertDriverError(error));
  }
}
```

**Why `db.exec()` instead of splitting by semicolons?**
- Handles semicolons inside strings correctly
- Handles multi-line statements
- Native SQLite parsing
- Matches official adapter behavior

### 8. Factory Pattern

The `PrismaBunSqlite` factory (lines 588-611):

```typescript
export class PrismaBunSqlite {
  readonly provider = "sqlite" as const;
  readonly adapterName = "prisma-adapter-bun-sqlite";

  async connect(): Promise<SqlDriverAdapter> {
    const db = new Database(this.dbPath);

    // Configure SQLite for optimal Prisma usage
    db.run("PRAGMA foreign_keys = ON");      // Required for cascades
    db.run("PRAGMA busy_timeout = 5000");    // Handle locks
    db.run("PRAGMA journal_mode = WAL");     // Performance

    return new BunSqliteAdapter(db, this.options);
  }
}
```

## Critical Fixes in v0.1.1

This section documents critical bugs discovered and fixed after the initial v0.1.0 release.

### 1. Data Corruption with Duplicate Column Names (CRITICAL)

**The Bug:**

When queries returned duplicate column names (common in JOINs), using `stmt.all()` caused data corruption:

```typescript
// Query: SELECT User.id, Profile.id, User.name, Profile.bio FROM User JOIN Profile ...
// BEFORE (BUGGY):
const rows = stmt.all(...args);
// Returns: [{ id: 10, name: "Alice", bio: "..." }]
// ❌ Lost User.id! Only kept Profile.id

const rowArrays = rows.map(row => columnNames.map(col => row[col]));
// Returns: [[10, 10, "Alice", "..."]]  // Wrong! Both IDs are the same
```

**The Fix:**

Changed to `stmt.values()` which returns arrays instead of objects:

```typescript
// AFTER (FIXED):
const rowArrays = stmt.values(...args);
// Returns: [[5, 10, "Alice", "..."]]  // Correct! User.id=5, Profile.id=10
```

**Impact:** Without this fix, any query with duplicate column names would silently return wrong data.

**Test Added:** `$queryRaw - preserves all columns in joins (duplicate names)` (line 753 in test-suite.ts)

### 2. Error Mapping Broken (CRITICAL)

**The Bug:**

Bun SQLite errors sometimes only have `.errno` (number) without `.code` (string):

```typescript
// Bun returns: { errno: 1, code: undefined, message: "..." }
// BEFORE (BUGGY):
if (!error?.code) throw error;  // ❌ Unhandled error!
```

**The Fix:**

Added full errno-to-code mapping:

```typescript
const SQLITE_ERROR_MAP: Record<number, string> = {
  1: "SQLITE_ERROR",
  5: "SQLITE_BUSY",
  2067: "SQLITE_CONSTRAINT_UNIQUE",
  // ... all 25+ SQLite error codes
};

function convertDriverError(error: any): any {
  // Accept both .code and .errno
  const code = error.code || SQLITE_ERROR_MAP[error.errno] || "SQLITE_UNKNOWN";
  // ... rest of error mapping
}
```

**Impact:** Without this fix, many errors (missing table, syntax errors) were not properly wrapped as Prisma errors.

**Tests Added:**
- `Missing table error is properly wrapped (errno-only error)` (line 993)
- `Syntax error is properly wrapped (errno-only error)` (line 1003)

### 3. BigInt Precision Loss Prevention

**The Issue:**

JavaScript numbers can't safely represent integers beyond `Number.MAX_SAFE_INTEGER` (2^53-1), but SQLite supports 64-bit integers (2^63-1).

**The Solution:**

Enable `safeIntegers: true` by default:

```typescript
export type PrismaBunSqliteOptions = {
  /**
   * Enable safe 64-bit integer handling.
   * When true, BIGINT columns return as BigInt instead of number,
   * preventing precision loss for values > Number.MAX_SAFE_INTEGER.
   * @default true
   */
  safeIntegers?: boolean;
};

// In factory:
const safeIntegers = this.config.safeIntegers !== false;  // Default: true
const db = new Database(dbPath, { safeIntegers });
```

**Impact:** Prevents silent data corruption when working with large integers (timestamps, IDs, etc).

**Test Added:** `BigInt handling - maximum 64-bit values (2^63-1)` (adapter-specific)

### 4. Statement Metadata Access (ACCEPTABLE RISK)

**The Issue:**

We access undocumented Bun APIs to get query metadata:

```typescript
const columnNames = (stmt as any).columnNames || [];
const declaredTypes = (stmt as any).declaredTypes || [];
```

**Why Needed:**

- Essential for preserving column order in results
- Required for proper type coercion
- No official Bun API exists (as of Bun v1.1.x)

**Safeguards:**

1. Fallback to empty arrays if properties don't exist
2. Detect column count mismatches and generate placeholder names:
   ```typescript
   if (firstRow && firstRow.length > columnNames.length) {
     const missingCount = actualColumnCount - columnNames.length;
     for (let i = 0; i < missingCount; i++) {
       columnNames.push(`column_${columnNames.length}`);
     }
   }
   ```

**Status:** Acceptable risk. Works reliably in practice. Future improvements:
- File Bun issue to make these official APIs
- Add runtime checks for property existence
- Document in code comments

**Documented:** Added explanatory comments in v0.1.1 (see lines 382-387 in src/adapter.ts)

## Reliability Review (v0.4.4+)

This section documents the comprehensive reliability review comparing our adapter against official Prisma adapters.

### Verified Correct (Matches Official better-sqlite3)

1. **Transaction handling** - `usePhantomQuery: false`, commit/rollback just release lock
2. **Error handling** - `convertDriverError` pattern with proper Prisma error kinds
3. **Isolation level validation** - Rejects non-SERIALIZABLE with `InvalidIsolationLevel`
4. **executeScript** - Uses native `db.exec()` for multi-statement scripts
5. **dispose()** - Properly closes database
6. **Factory pattern** - Implements `SqlMigrationAwareDriverAdapterFactory`
7. **Safe integers** - Enabled by default (like official)
8. **DateTime format** - Uses `+00:00` suffix (matches official)

### Extra Defensive Features (Beyond Official)

1. **Transaction state tracking** - Throws `TransactionAlreadyClosed` on misuse
2. **PRAGMA settings** - `foreign_keys=ON`, `busy_timeout=5000` (official sets NONE!)
3. **Custom AsyncMutex** - 34-line impl vs `async-mutex` package
4. **lastInsertId support** - Returns lastInsertId for INSERT/UPDATE/DELETE (like libsql)

### Differences from Official (Intentional)

1. **PRAGMA foreign_keys = ON**
   - Official: Does NOT enable foreign keys
   - Ours: Enables by default
   - Rationale: Prisma schemas with relations expect FK constraints to work
   - This is a FEATURE, not a bug

2. **Statement metadata**
   - Official: Uses `stmt.reader` check for non-returning queries
   - Ours: Uses Bun's `stmt.declaredTypes` and `stmt.columnNames` + `stmt.run()` for non-returning
   - Both work correctly, different approaches

3. **lastInsertId**
   - Official better-sqlite3: Does NOT return lastInsertId
   - Official libsql: Returns lastInsertId
   - Ours: Returns lastInsertId (matches libsql pattern)

### No Brittle Patterns

- ✅ NO SQL parsing for COMMIT/ROLLBACK detection
- ✅ NO regex-based table name extraction for transactions
- ✅ NO string splitting for error code extraction (use errno mapping)

### Official Test Suite Coverage

The adapter includes 40 tests ported from Prisma's official SQLite test scenarios and the quaint Rust engine:

```
tests/official-scenarios.test.ts - 40 tests covering:
├── Simple queries (SELECT, INSERT, UPDATE, DELETE)
├── Boolean handling (true/false ↔ 1/0)
├── DateTime handling (ISO8601 format)
├── Decimal handling (as TEXT)
├── Foreign key constraints
├── Composite primary keys
├── String operations (LIKE, IN)
├── NULL handling
├── Ordering (ASC/DESC)
├── Transactions (commit, rollback)
├── Error handling (constraint violations)
├── executeScript (multi-statement SQL)
├── Shadow database support
├── lastInsertId for non-returning statements
└── Edge cases from prisma-engines/quaint:
    ├── DateTime from YYYY-MM-DD HH:MM:SS format
    ├── DateTime from RFC3339 format
    ├── Column not found on read/write
    ├── Integer boundaries (i32 min/max)
    ├── BigInt boundaries (i64 min/max)
    └── Multi-statement script error detection
```

---

## Comparison with Official Rust Query Engine (quaint)

This section documents findings from analyzing the official Prisma Rust query engine (`prisma-engines/quaint`) - the pre-Prisma-7 implementation that handled all SQLite operations.

### Error Codes - IDENTICAL ✅

The Rust engine uses the exact same SQLite extended error codes:

```rust
// From quaint/src/connector/sqlite/ffi.rs
pub const SQLITE_BUSY: i32 = 5;
pub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;
pub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;
pub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;
pub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;
pub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;
```

Our error handling matches exactly.

### PRAGMA Settings - We're MORE Defensive

| PRAGMA | Official Rust Engine | Our Adapter | Notes |
|--------|---------------------|-------------|-------|
| `foreign_keys` | ❌ NOT SET | ✅ `ON` | We enforce FK constraints |
| `busy_timeout` | ❌ Only if URL param | ✅ `5000ms` | We prevent lock hangs |
| `journal_mode` | ❌ NOT SET | Optional WAL | Opt-in for performance |

**Rationale for our defaults:**
- `foreign_keys=ON`: Prisma schemas with `@relation` expect FK constraints to work. Not enabling this silently ignores constraint violations.
- `busy_timeout=5000`: Without this, locked databases cause immediate errors instead of waiting. 5 seconds is a reasonable default.
- WAL mode: Kept as opt-in because it changes file structure (creates `-wal` and `-shm` files).

### Transaction BEGIN Statement

| | Official Rust Engine | better-sqlite3 Adapter | Our Adapter |
|--|---------------------|------------------------|-------------|
| Statement | `BEGIN IMMEDIATE` | `BEGIN` | `BEGIN` |

**Why we use `BEGIN` (not `BEGIN IMMEDIATE`):**

The Rust engine uses `BEGIN IMMEDIATE` to avoid `SQLITE_BUSY_SNAPSHOT` errors when multiple connections compete for write locks. However:

1. **We have a mutex**: Our `AsyncMutex` serializes all transactions at the adapter level
2. **Single connection**: We don't use connection pooling
3. **Matches better-sqlite3**: The TypeScript adapter we're most similar to uses plain `BEGIN`

`BEGIN IMMEDIATE` would only help with concurrent connections, which we don't have.

### DateTime Storage Format

| | Official Rust Engine | better-sqlite3 Adapter | Our Adapter |
|--|---------------------|------------------------|-------------|
| Default | `unixepoch-ms` (integer) | `iso8601` (string) | `iso8601` (string) |
| Configurable | No | Yes | Yes |

**Why we default to ISO8601:**

| Aspect | ISO8601 | Unix millis |
|--------|---------|-------------|
| Human readable | ✅ `2024-01-15T10:30:00+00:00` | ❌ `1705315800000` |
| SQLite date functions | ✅ `datetime()`, `date()` work | ❌ Need conversion |
| DB browser inspection | ✅ Easy to read | ❌ Need to decode |
| Storage size | ~25 bytes | 8 bytes |
| Sort/compare speed | Slower (string) | Faster (integer) |

For most applications, readability and SQLite function compatibility outweigh the small performance difference. Users who need raw performance can opt into `unixepoch-ms`.

### lastInsertId

```rust
// From quaint/src/connector/sqlite/native/mod.rs:118
result.set_last_insert_id(u64::try_from(client.last_insert_rowid()).unwrap_or(0));
```

The Rust engine returns `lastInsertId` for all queries. We now match this behavior.

### Isolation Level

Both the Rust engine and our adapter only support `SERIALIZABLE`:

```rust
// Rust engine
if !matches!(isolation_level, IsolationLevel::Serializable) {
    return Err(invalid_isolation_level);
}
```

SQLite is inherently serializable; other isolation levels would require shared cache mode.

### Summary: Our Adapter vs All Official Implementations

| Feature | Rust Engine | better-sqlite3 | libsql | **Our Adapter** |
|---------|------------|----------------|--------|-----------------|
| `foreign_keys` | ❌ Off | ❌ Off | ❌ Off | ✅ **On** |
| `busy_timeout` | ❌ Manual | ❌ None | ❌ None | ✅ **5000ms** |
| `BEGIN` type | `IMMEDIATE` | `BEGIN` | `BEGIN` | `BEGIN` |
| DateTime default | `millis` | `iso8601` | `iso8601` | `iso8601` |
| lastInsertId | ✅ Yes | ❌ No | ✅ Yes | ✅ **Yes** |
| Error codes | ✅ Full | ✅ Full | ✅ Full | ✅ **Full** |

**Conclusion:** Our adapter is **more production-ready** than all official implementations due to defensive PRAGMA defaults.

---

## New Features in v0.2.0

### 1. Shadow Database Support

**What it enables:**
- Full `prisma migrate dev` compatibility
- Migration testing and diffing
- Works with `prisma.config.ts` and JS engine

**Implementation:**

The factory class now implements `SqlMigrationAwareDriverAdapterFactory`:

```typescript
export class PrismaBunSqlite implements SqlMigrationAwareDriverAdapterFactory {
  async connectToShadowDb(): Promise<SqlDriverAdapter> {
    // Defaults to :memory: for speed
    const shadowUrl = this.config.shadowDatabaseUrl ?? ":memory:";
    const db = this.createConnection(shadowUrl);
    return new BunSqliteAdapter(db, this.config);
  }
}
```

**Key features:**
- Shadow DB defaults to `:memory:` for maximum speed
- Inherits all config options (safeIntegers, timestampFormat)
- Completely isolated from main database
- WAL mode automatically disabled for :memory: databases

**Test coverage:** 9 comprehensive tests ensuring shadow DB works correctly

---

### 2. Programmatic Migration Utilities

**New module:** `src/migrations.ts` (372 lines)

**What it enables:**
- Run migrations from TypeScript code
- Create :memory: databases with migrations (lightning fast tests!)
- Embed migrations in standalone Bun binaries
- Custom migration workflows

**API Overview:**

```typescript
// Create test database with migrations
const adapter = await createTestDatabase([
  { name: "001_init", sql: "CREATE TABLE users (...);" }
]);

// Run migrations manually
await runMigrations(adapter, migrations, {
  logger: console.log,
  skipApplied: true  // Default
});

// Load migrations from filesystem
const migrations = await loadMigrationsFromDir("./prisma/migrations");

// Query migration status
const applied = await getAppliedMigrations(adapter);
const pending = await getPendingMigrations(adapter, allMigrations);
```

**Migration Tracking:**

Uses Prisma-compatible `_prisma_migrations` table:

```sql
CREATE TABLE _prisma_migrations (
  id TEXT PRIMARY KEY,
  checksum TEXT NOT NULL,
  migration_name TEXT NOT NULL,
  finished_at DATETIME,
  started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  applied_steps_count INTEGER DEFAULT 0
);
```

**Test coverage:** 11 comprehensive tests covering all migration utilities

---

### 3. Type System Improvements

**Before (v0.1.x):**
```typescript
export type PrismaBunSqlite3Options = { ... }  // Inconsistent naming
export type PrismaBunSqliteConfig = { ... }
```

**After (v0.2.0):**
```typescript
export type PrismaBunSqliteOptions = { ... }   // Consistent naming
export type PrismaBunSqliteConfig = {
  url: string;
  shadowDatabaseUrl?: string;  // New!
} & PrismaBunSqliteOptions;
```

**Changes:**
- Renamed `PrismaBunSqlite3Options` → `PrismaBunSqliteOptions` (consistent with class name)
- Added `shadowDatabaseUrl` to config
- Better JSDoc comments throughout
- All TypeScript strict mode errors fixed

---

### 4. Test Structure Simplification

**Before (v0.1.x):**
- `tests/common/test-suite.ts` - Shared test suite
- `tests/adapter.test.ts` - Wrapper for bunsqlite
- `tests/libsql-adapter.test.ts` - Wrapper for libsql (baseline)
- Dependency on `@prisma/adapter-libsql`

**After (v0.2.0):**
- `tests/general.test.ts` - All core adapter tests (57 tests)
- `tests/migrations.test.ts` - Migration utility tests (11 tests)
- `tests/shadow-database.test.ts` - Shadow DB tests (9 tests)
- **Zero external adapter dependencies**

**Benefits:**
- Simpler test structure
- Faster CI (no libsql baseline needed)
- Easier to maintain
- Cleaner codebase

---

### 5. Examples and Documentation

**New Examples:**
- `examples/standalone-binary.ts` - Embedded migrations in Bun binary
- `examples/bundle-with-migration-files.ts` - Bundle Prisma migrations at build time
- `examples/test-with-memory-db-example.ts` - :memory: testing patterns
- `examples/README.md` - Complete guide with deployment strategies

**Updated Documentation:**
- README.md - Added migration utilities section
- CHANGELOG.md - Comprehensive v0.2.0 entry
- BACKLOG.md - Marked shadow DB as completed
- prisma.config.ts - Now uses JS engine with adapter

---

## Comparison with Official Adapters

### vs `@prisma/adapter-better-sqlite3`

| Feature | better-sqlite3 | bun:sqlite (ours) |
|---------|----------------|-------------------|
| **Runtime** | Node.js | Bun |
| **API Type** | Synchronous | Synchronous |
| **Dependencies** | `better-sqlite3` (native) | Zero (Bun built-in) |
| **executeScript** | `db.exec()` | `db.exec()` ✅ |
| **Error Codes** | String codes + errno map | String codes + errno map ✅ |
| **Argument Mapping** | `mapArg()` | `mapArg()` ✅ |
| **Boolean Conversion** | `1/0` | `1/0` ✅ |
| **usePhantomQuery** | `false` (Prisma handles tx) | `false` (Prisma handles tx) ✅ |
| **Transaction Method** | commit()/rollback() release lock | commit()/rollback() release lock ✅ |
| **Transaction Safety** | `async-mutex` library | Custom AsyncMutex (34 lines) |
| **Column Detection** | `stmt.columns()` API | `stmt.values()` + metadata |
| **DateTime Format** | Options support | Options support ✅ |
| **Safe Integers** | Optional | Default enabled ✅ |
| **lastInsertId** | Not returned | Returned for INSERT/UPDATE/DELETE ✅ |

**Key Differences:**

1. **Transaction Lifecycle** (MATCHES OFFICIAL):
   - **better-sqlite3**: Uses `usePhantomQuery: false`, so Prisma Engine sends COMMIT/ROLLBACK queries via executeRaw(). The adapter's `commit()` method just releases a mutex.
   - **Ours**: Uses `usePhantomQuery: false` (same pattern). Prisma engine sends COMMIT/ROLLBACK SQL, our commit()/rollback() release the lock.
   - **Both identical**: We match the official better-sqlite3 adapter pattern exactly.

2. **Transaction Locking**:
   - **better-sqlite3**: Uses `async-mutex` npm package (dependency)
   - **Ours**: Custom AsyncMutex implementation (34 lines, zero dependencies)
   - **Rationale**: SQLite is single-threaded; simple queue-based mutex sufficient

3. **Column Data Retrieval**:
   - **better-sqlite3**: Uses `stmt.all()` to get objects, then `stmt.columns()` for metadata
   - **Ours**: Uses `stmt.values()` to get arrays (preserves duplicate columns)
   - **Rationale**: Arrays prevent data corruption when column names duplicate (JOINs)

4. **Safe Integers**:
   - **better-sqlite3**: Opt-in (`safeIntegers: false` by default)
   - **Ours**: Opt-out (`safeIntegers: true` by default)
   - **Rationale**: Prevent silent data corruption by default

### vs `@prisma/adapter-libsql`

| Feature | libsql | bun:sqlite (ours) |
|---------|--------|-------------------|
| **Runtime** | Node.js or Bun | Bun only |
| **API Type** | Async (can be networked) | Sync (local only) |
| **Network Support** | ✅ (Turso, remote) | ❌ (local file only) |
| **Dependencies** | `@libsql/client` | Zero |
| **Connection** | URL-based | File path |
| **Transaction** | Automatic via libsql | Manual BEGIN/COMMIT |

**When to use which:**

- **Use libsql** if you need networked SQLite (Turso), edge deployment
- **Use bun:sqlite** for local-only apps, maximum performance, zero deps

## Design Decisions

### 1. Why Manual Transaction Management?

**Decision**: Use manual `BEGIN`/`COMMIT`/`ROLLBACK` instead of `db.transaction()`

**Reasoning**:
- Matches official better-sqlite3 adapter pattern
- Prisma expects to control transaction lifecycle
- `db.transaction()` returns a function, incompatible with Prisma's API
- All tests pass with manual approach

**Code**:
```typescript
// ❌ Can't use this - returns a function
const txFunc = db.transaction(() => {
  db.run("INSERT ...");
  db.run("UPDATE ...");
});
txFunc(); // Executes

// ✅ Instead use this - Prisma-compatible
db.run("BEGIN");
db.run("INSERT ...");
db.run("UPDATE ...");
db.run("COMMIT");
```

### 2. Why `usePhantomQuery: false`?

**Decision**: Set `usePhantomQuery: false` in transaction options (matches official better-sqlite3 adapter)

**What it means**:
- When `false`: Prisma Engine sends explicit COMMIT/ROLLBACK queries through executeRaw(), adapter's commit()/rollback() just release the mutex lock
- When `true`: Adapter must call BEGIN/COMMIT/ROLLBACK explicitly in commit()/rollback() methods

**Reasoning**:
- **Matches official `@prisma/adapter-better-sqlite3`** - same pattern, same behavior
- Cleaner separation: Engine controls transaction SQL, adapter controls locking
- Simpler implementation: commit()/rollback() are just mutex unlocks
- No edge cases: No need to intercept or special-case COMMIT/ROLLBACK SQL

**Trade-offs**:
- ✅ Exact match with official better-sqlite3 adapter pattern
- ✅ Cleaner separation of concerns
- ✅ Simpler commit()/rollback() implementation

**Changed**: v0.4.0 switched from `usePhantomQuery: true` to `false` to match official adapter

### 3. Why PRAGMA for Column Types?

**Decision**: Use `PRAGMA table_info()` instead of `stmt.columns()`

**Reasoning**:
- bun:sqlite doesn't expose `stmt.columns()` API
- PRAGMA gives schema-declared types, not runtime-inferred
- More accurate for type coercion (e.g., BLOB columns)
- Works with all query types (SELECT, INSERT, etc.)

### 4. Why String Error Codes?

**Decision**: Use string codes (`"SQLITE_CONSTRAINT_UNIQUE"`) not numeric

**Reasoning**:
- bun:sqlite provides string codes natively
- More readable and maintainable
- Matches better-sqlite3 adapter exactly
- No need for numeric code mappings

### 5. Why Options Support?

**Decision**: Add `PrismaBunSqliteOptions` with `timestampFormat`

**Reasoning**:
- Matches official adapter API
- Some users prefer Unix timestamps over ISO8601
- Allows future extensibility
- Zero overhead if not used

## Code Organization

### File Structure

```
src/
├── adapter.ts    # Main adapter implementation
│   ├── Types & Interfaces
│   ├── Type Mapping
│   ├── Row Conversion
│   ├── Argument Mapping
│   ├── Error Conversion
│   ├── BunSqliteQueryable (Base)
│   ├── BunSqliteTransaction
│   ├── BunSqliteAdapter
│   └── PrismaBunSqlite Factory
├── migrations.ts           # Migration utilities (v0.2.0+)
│   ├── runMigrations()
│   ├── createTestDatabase()
│   ├── loadMigrationsFromDir()
│   ├── getAppliedMigrations()
│   └── getPendingMigrations()
└── index.ts                # Public exports

tests/
├── general.test.ts         # Core adapter tests (57 tests)
├── migrations.test.ts      # Migration utilities tests (11 tests)
└── shadow-database.test.ts # Shadow DB tests (9 tests)

prisma/
├── schema.prisma           # Test schema
└── generated/              # Generated Prisma Client

examples/                   # v0.2.0+ examples
├── standalone-binary.ts
├── bundle-with-migration-files.ts
├── test-with-memory-db-example.ts
└── README.md
```

### Key Functions

| Function | Lines | Purpose |
|----------|-------|---------|
| `mapDeclType()` | 27-69 | Maps SQLite type names to Prisma ColumnType |
| `inferColumnType()` | 74-92 | Infers column type from runtime value |
| `getColumnTypes()` | 97-124 | Combines declared + inferred types |
| `mapRow()` | 129-187 | Converts SQLite row to Prisma format |
| `mapArg()` | 201-256 | Converts Prisma arg to SQLite format |
| `convertDriverError()` | 262-349 | Maps SQLite errors to Prisma errors |
| `getColumnTypesForQuery()` | 430-467 | Detects column types via PRAGMA |

## Testing Strategy

### Test Structure (v0.2.0+)

**Test Suites:**

1. **`tests/general.test.ts`** - Core adapter functionality (57 tests)
   - CRUD operations (12 tests)
   - Relations (6 tests)
   - Filtering & querying (9 tests)
   - Aggregations (3 tests)
   - Transactions (3 tests)
   - Raw queries (4 tests)
   - Type coercion (7 tests)
   - Error handling (4 tests)
   - Edge cases (6 tests)
   - Includes regression tests for v0.1.1 critical fixes

2. **`tests/migrations.test.ts`** - Migration utilities (11 tests)
   - runMigrations applies migrations
   - runMigrations skips already applied
   - runMigrations tracks in _prisma_migrations
   - getAppliedMigrations returns list
   - getPendingMigrations returns unapplied
   - createTestDatabase creates :memory: with migrations
   - Complex SQL with comments
   - Idempotent migrations
   - Foreign key preservation

3. **`tests/shadow-database.test.ts`** - Shadow DB (9 tests)
   - Creates separate adapter instances
   - Defaults to :memory:
   - Supports custom URL
   - Isolated from main database
   - executeScript support
   - Multiple usage
   - Config inheritance (safeIntegers, timestampFormat)

**Test Categories:**

1. **CRUD Operations** (12 tests)
   - create, findUnique, findMany, findFirst
   - update, updateMany, delete, deleteMany
   - upsert, count

2. **Relations** (6 tests)
   - Nested creates
   - Include queries
   - Cascade deletes

3. **Filtering & Querying** (9 tests)
   - Where clauses
   - OrderBy, pagination
   - Distinct

4. **Aggregations** (3 tests)
   - count(), aggregate(), groupBy()

5. **Transactions** (3 tests)
   - Interactive commit
   - Interactive rollback
   - Sequential

6. **Raw Queries** (4 tests)
   - $queryRaw SELECT
   - $executeRaw INSERT/UPDATE/DELETE

7. **Type Coercion** (7 tests)
   - DateTime, BigInt, Boolean
   - Decimal, JSON, Bytes
   - Null handling

8. **Error Handling** (4 tests)
   - P2002 (unique constraint)
   - P2003 (foreign key)
   - P2025 (record not found)
   - P2011 (null constraint)

9. **Edge Cases** (6 tests)
   - Empty strings
   - Large numbers
   - Special characters
   - Concurrent operations

### Running Tests

```bash
# All tests (77 tests total)
bun test

# Core adapter only
bun test tests/general.test.ts

# Migration utilities only
bun test tests/migrations.test.ts

# Shadow database only
bun test tests/shadow-database.test.ts

# Verbose output
bun test --verbose
```

### Test Results

```
✅ General Tests:              57/57 tests passing
✅ Migration Tests:            12/12 tests passing
✅ Shadow Database Tests:       9/9 tests passing
✅ WAL Configuration Tests:    13/13 tests passing
✅ Official Scenarios Tests:   40/40 tests passing
──────────────────────────────────────────────────────
✅ Total:                     131/131 tests passing
```

**Test Evolution:**
- v0.1.0: 110 tests
- v0.1.1: 113 tests (added regression tests)
- v0.2.0: 77 tests (consolidated + new features, removed baseline duplication)
- v0.4.4+: 131 tests (added official scenarios, WAL tests, edge cases from prisma-engines)

## Performance Considerations

### Optimizations

1. **Prepared Statements**: All queries use `db.prepare()`
2. **WAL Mode**: Enabled by default for better concurrency
3. **Type Caching**: Column types cached per query
4. **Direct API**: No middleware, direct `bun:sqlite` calls

### Benchmarks

(TODO: Add benchmarks comparing with better-sqlite3 and libsql)

## Future Improvements

### Planned Enhancements (See `BACKLOG.md`)

**High Priority (Next Release):**
1. **Debug Logging**: Add `Debug` from `@prisma/driver-adapter-utils` for troubleshooting
2. **Dead Code Removal**: Remove unused `getColumnTypesForQuery()` method
3. **Base64 BLOB Investigation**: Document or remove base64 BLOB handling code
4. **Statement Metadata Safety**: File Bun issue to make `columnNames`/`declaredTypes` official API

**Medium Priority:**
1. **Modular Structure**: Refactor into separate files (adapter.ts, transaction.ts, conversion.ts, errors.ts)
2. **Comprehensive JSDoc**: Add JSDoc comments to all public APIs

**v0.3.0 - Performance & Optimization:**
1. **Performance Benchmarks**: Add comprehensive benchmarks vs libsql and better-sqlite3
2. **usePhantomQuery: false**: Consider switching for fewer queries (requires transaction rewrite)
3. **Schema Caching**: Cache PRAGMA results to reduce repeated schema queries

**v1.0.0 - Production Hardening:**
1. **Extensive Production Testing**: Used in 3+ projects for 3+ months
2. **API Stability**: Lock API for semantic versioning
3. **Comprehensive Documentation**: Migration guides, troubleshooting, performance tuning

### Known Limitations

1. **SQLite Constraints**: Inherits all SQLite limitations (single writer, no network, etc.)
2. **Decimal Precision**: Limited by SQLite's lack of native decimal type
3. **Transaction Isolation**: Only SERIALIZABLE (SQLite limitation)
4. **Undocumented Bun APIs**: Relies on `columnNames`/`declaredTypes` properties (not officially documented)

## Contributing

When contributing, please:

1. **Read this document** to understand design decisions
2. **Run all tests** before submitting PR
3. **Add tests** for new features
4. **Follow existing patterns** (match official adapter style)
5. **Update documentation** if changing behavior

## References

- [Prisma Driver Adapters Docs](https://www.prisma.io/docs/orm/overview/databases/database-drivers)
- [Bun SQLite API](https://bun.sh/docs/api/sqlite)
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [Official better-sqlite3 Adapter](https://github.com/prisma/prisma/tree/main/packages/adapter-better-sqlite3)
- [Official libsql Adapter](https://github.com/prisma/prisma/tree/main/packages/adapter-libsql)
